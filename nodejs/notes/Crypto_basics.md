# [Crypto](https://nodejs.org/docs/latest/api/crypto.html#crypto)

The node:crypto module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions.

```js
const { createHmac } = require('node:crypto');

const secret = 'abcdefg';
const hash = createHmac('sha256', secret)
               .update('I love cupcakes')
               .digest('hex');
console.log(hash);
// Prints:
//   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e
```

The crypto module has the following classes

1. Certificate
2. Cipher
3. Decipher

## 1. Certificate

The Certificate class in the node:crypto module is used to work with X.509 certificate signing requests (CSRs) and certificates in Node.js. This class provides functionality for creating and verifying X.509 certificates, which are widely used in SSL/TLS for securing communications.

Key Uses of the Certificate Class

### Certificate Verification

The Certificate class can verify whether a certificate is signed by a trusted certificate authority (CA). This is commonly used in SSL/TLS implementations to ensure the authenticity of a certificate.

### SPKAC Handling

SPKAC stands for Signed Public Key and Challenge, a format generated by the HTML <keygen> tag. The Certificate class can handle SPKAC data, typically used in web-based certificate enrollment systems. The Certificate class provides methods to create certificates from SPKAC data or to verify this data.


### Common Use Cases:

`SSL/TLS Certificate Handling`: Although Node.js primarily relies on the OpenSSL library for handling SSL/TLS connections, the Certificate class can be used in custom implementations where you need to manipulate or verify certificates.
`Web-based Certificate Enrollment`: If youâ€™re building a web service that issues or verifies certificates, you can use the Certificate class to handle SPKAC data, which is often generated by web browsers during certificate enrollment processes.
`Custom Certificate Management`: For applications that need to manage certificates programmatically (e.g., a custom CA service), the Certificate class provides basic utilities to help with certificate creation and validation.

```js
const { Certificate } = require('crypto');
const fs = require('fs');

// Example SPKAC data (this would normally come from a real source)
const spkac = fs.readFileSync('path/to/spkac.pem');

// Verify the SPKAC data
if (Certificate.verifySpkac(spkac)) {
    console.log('SPKAC data is valid.');
    // Export the public key
    const publicKey = Certificate.exportPublicKey(spkac);
    console.log('Public Key:', publicKey.toString('utf-8'));
} else {
    console.log('SPKAC data is invalid.');
}
```

### Important Notes
`Limited Scope`: The Certificate class is somewhat specialized, focusing on SPKAC and basic certificate verification tasks. For more comprehensive certificate management tasks, such as creating certificate signing requests (CSRs) or managing full certificate chains, you would typically rely on OpenSSL or other dedicated libraries.
`Integration with Other Crypto Functions`: The Certificate class is part of the broader crypto module in Node.js, which includes other tools for encryption, hashing, and key management, allowing you to build secure applications.

Overall, the Certificate class is a useful utility for working with certain types of certificate data in Node.js, particularly in scenarios involving SPKAC handling and basic certificate verification.


## Cipher

Instances of the Cipher class are used to encrypt data. The class can be used in one of two ways:

As a stream that is both readable and writable, where plain unencrypted data is written to produce encrypted data on the readable side, or
Using the cipher.update() and cipher.final() methods to produce the encrypted data.
The crypto.createCipheriv() method is used to create Cipher instances. Cipher objects are not to be created directly using the new keyword.

```js
const {
  scrypt,
  randomFill,
  createCipheriv,
} = require('node:crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';

// First, we'll generate the key. The key length is dependent on the algorithm.
// In this case for aes192, it is 24 bytes (192 bits).
scrypt(password, 'salt', 24, (err, key) => {
  if (err) throw err;
  // Then, we'll generate a random initialization vector
  randomFill(new Uint8Array(16), (err, iv) => {
    if (err) throw err;

    // Once we have the key and iv, we can create and use the cipher...
    const cipher = createCipheriv(algorithm, key, iv);

    let encrypted = '';
    cipher.setEncoding('hex');

    cipher.on('data', (chunk) => encrypted += chunk);
    cipher.on('end', () => console.log(encrypted));

    cipher.write('some clear text data');
    cipher.end();
  });
});
```